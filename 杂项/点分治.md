## 点分治真的很暴力

整体思想有点像dsu on tree，复杂度是 $O(n\log^2n)$ 的

用于处理树上路径问题，例如：求一个带边权的树上，长度为 $k$ 的路径数

定义 $work(p,k)$ 为在以 $p$ 为根节点的子树中，长度为 $k$ 的路径数量（不去重），为什么要说不去重后面再讲

我们可以把路径分成两部分：

- 经过 $p$ 点的
- 出现在某个子树中的

第二部分我们可以递归解决，考虑第一部分

首先可以暴力dfs出 $p$ 到每一个子孙节点路径，扔进一个数组里，从这些路径里面拿两个出来就可以拼成一条经过 $p$ 的路径，当然存在不合法的（两条路径终点在同一子树中），先不管它，直接统计出**未去重的**长度为 $k$ 的数量。

然后考虑去重：不能让两个终点在同一个子树中，那么只需要枚举子树，将贡献减去 $work(v,k-2\times w)$ 即可，$w$ 为向子树 $v$ 连边的权值。

为什么是 $k-2\times w$ 很好理解，但 $work$ 计算的不是**不去重的**路径吗？这样减去的子树也没有去重，为什么是正确的？

事实上，我们需要减去的子树就是不能去重的，我们关心的是子树中出现了多少节点对 $(x,y)$： $x$ 连向 $v$，再连向 $y$ 的长度为 $k-w\times2$。需要去除的就是这样的点对，而非 $x,y$ 间距离为 $k-w\times2$ 的点对。

```c++
int n, m;
vector<pair<int, int>> vp[maxn];
bool vis[maxn];
int mxv[maxn], siz[maxn];

int getroot(int p, int fa, int tot){//找重心，tot为这个子树整个大小
    siz[p] = 1;
    mxv[p] = 0;
    mxv[0] = INF;
    int rt = 0;
    for(auto e: vp[p]){
        int v = e.first;
        if(v == fa || vis[v]) continue;
        int vrt = getroot(v, p, tot);
        siz[p] += siz[v];
        mxv[p] = max(mxv[p], siz[v]);
        if(mxv[vrt] < mxv[rt]) rt = vrt;
    }
    mxv[p] = max(mxv[p], tot - siz[p]);
    if(mxv[p] < mxv[rt]) rt = p;
    return rt;
}

void getdis(int p, int fa, int dis, vector<int> &all){
    all.push_back(dis);
    for(auto v: vp[p]){
        if(v.first == fa || vis[v.first]) continue;
        getdis(v.first, p, dis + v.second, all);
    }
}

ll calcu(int p, int k){//处理以p为根节点的所有路径（不去重！）
    vector<int> all;
    getdis(p, -1, 0, all);
    //主要修改下面的计算部分，all中得到了经过p的所有路径长度（不去重）
    int cnt[3] = {0, 0, 0};
    for(int x: all) cnt[x % 3]++;
    if(k == 1) k = 2;
    else if(k == 2) k = 1;
    ll res = (cnt[k] * cnt[k] + cnt[k]) / 2;
    cnt[k] = 1;
    res += 1ll * cnt[0] * cnt[1] * cnt[2];
    return res;
}

ll work(int p){
    vis[p] = true;
    ll ans = calcu(p, 0);
    //这里计算的 是p节点，向任意两个子孙节点连边拼成的路径
    for(auto v: vp[p]){
        if(vis[v.first]) continue;
        ans -= calcu(v.first, (3 - 2 * v.second % 3) % 3);
        //去掉两点都取在同一个子树中的情况，这里就是要减去 子树“未去重的”的情况！
        int rt = getroot(v.first, p, siz[v.first]);
        ans += work(rt);
    }
    return ans;
}

void solve(){
    cin >> n;
    for(int i=1;i<n;i++){
        int x, y, w;
        cin >> x >> y >> w;
        vp[x].emplace_back(y, w);
        vp[y].emplace_back(x, w);
    }
    int rt = getroot(1, 0, n);
    ll ans = work(rt);
}
```



有了dsu on tree的经验，我们容易得出这个复杂度为 $O(nlog^2n)$