## 笛卡尔树

一个被忽略的非常优秀的数据结构，构建仅需 $O(n)$，却能同时有二叉搜索树和堆的性质。

虽然是个平衡树，但一般不拿来当平衡树用..

它的每个节点有两个权值 $k,w$，其中 $k$ 满足二叉搜索树性质，$w$ 满足堆性质。

构建：给定 $n$ 个二元组 $(k,w)$，我们首先将 $k$ 排序，然后依次插入。因为 $k$ 有序，我们插入时只需要在右链插入即可。然后根据 $w$ 值不断上旋。我们用一个栈来维护右链，当一个结点被旋下去即从栈顶弹出。这个右链其实恰恰就是一个单调栈，每个节点仅出栈一次，故构建复杂度是 $O(n)$ 的

事实上，我们甚至不需要写麻烦的旋转操作，观察图容易发现，我们把一系列节点弹出栈后，只需要将最后一个出栈的节点连到新节点的左子树上即可，其他树上结构无需改变。因此，这个构建过程甚至是一个小常数的 $O(n)$

oiwiki的图：

![](https://oi-wiki.org/ds/images/cartesian-tree2.png)

很多情况下，我们直接拿数组的下标作为 $k$ 值，权值作为 $w$ 值，这样构建的笛卡尔树有一个优秀性质：

- 一棵子树表示一个连续的区间，其中根节点为这个区间最值。

我们会发现，这样的笛卡尔树好像就是个单调栈，只不过用树的形式维护了。这使得单调栈的逻辑更加清晰：我们不再需要一堆指针来搞单调栈，关注它的边界等等。同时，还因为它是个树上的结构，我们还可以在它上面跑一些奇怪的东西。

```c++
int n, a[maxn];
int l[maxn], r[maxn];

int stk[maxn], h;
int build(){
    h = 0;
    for(int i=1;i<=n;i++){
        while(h && a[i] < a[stk[h]]) ls[i] = stk[h--];
        if(h) rs[stk[h]] = i;
        stk[++h] = i;
    }
    return stk[1];//根节点
}
//单调栈也就这么短吧？
```



##### 例题：[玛卡巴卡玩游戏](https://ac.nowcoder.com/acm/contest/11187/E)

题意修改一下，就是让你求**区间总和大于最大值两倍的区间数量**，并且要求区间总和是偶数

考虑枚举每一个值作为区间最值的情况，那么先用单调栈搞出来每个值的 $l,r$，表示它左边和右边第一个大于它的位置

枚举每个值，在它的 $l,r$ 范围内统计。可以二分可以双指针，但有两点恶心人：

- 要求区间总和是偶数，我们必须把奇偶数的情况分开来考虑。
- 如果对每个 $l,r$ 都扫一遍的话，复杂度还是会达到 $n^2$
  - 这里有个小技巧：如果只扫每个数到**离它最近的比它大的位置**的话，总区间长度就是 $O(n)$ 的了
  - 那么对于每个点，都看一下它距离 $l,r$ 哪边更长，选择一遍扫，另一边二分+前缀和

前缀和当然也得分奇偶数考虑，这么搞起来极麻，边界一堆...

https://ac.nowcoder.com/acm/contest/view-submission?submissionId=51271999



##### 换个思路

我们直接构建笛卡尔树

