## 后缀数组

#### 主要参考：

[OI WIKI 后缀数组简介](https://oi-wiki.org/string/sa/)



#### 按照个人理解的部分修改（相较于wiki代码）：

朴素的$nlogn$做法修改（通过洛谷模板题）

这种做法常数较大，没有优化，但更朴素，适用于不同情况，例如 [P5353树上后缀排序](https://www.luogu.com.cn/problem/P5353)

```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
#include <stdio.h>
#include <iostream>
using namespace std;
#define ll long long
const int maxn=1000005;
int mode=998244353;
void Swap(int *a, int *b){int ins=*a;*a=*b;*b=ins;}

string s;
int sa[maxn],rk[maxn<<1];
int ins[maxn],cnt[maxn];
//此处用一个ins数组替代了wiki中的id，oldrk数组
//个人认为这两个数组本质是暂存，写成id、oldrk易引起误解

int n;
int m = 140;

void solve(){
    cin>>s;
    n=s.size();
    s=' '+s;

    for(int i=1;i<=n;i++) cnt[rk[i] = s[i]]++;
    for(int i=1;i<=m;i++) cnt[i] += cnt[i-1];
    //下面这句可以改遍历顺序，因为无须关注排序的稳定性
    //要稳定的话，必须从n到1遍历（后来的领取较大的排名）
    for(int i=1;i<=n;i++) sa[cnt[rk[i]]--] = i;

    int tail;
    for(int w=1;;w<<=1){

        memset(cnt,0,sizeof(int)*(m+5));

        //这一段有所修改，下文注释部分是oiwiki源码
        //理由是，对第二关键字的排序无须考虑稳定性
        //可以省去一个id数组，这里只需要简单地根据第二关键字，塞进桶拿出来就行
        for(int i=1;i<=n;i++) cnt[rk[i+w]]++;
        for(int i=1;i<=m;i++) cnt[i] += cnt[i-1];
        //这里也可以改遍历顺序，第二关键字排序不关注稳定性
        for(int i=1;i<=n;i++) sa[cnt[rk[i+w]]--] = i;
        
        //for (i = 1; i <= n; ++i) id[i] = sa[i];
    	//for (i = 1; i <= n; ++i) ++cnt[rk[id[i] + w]];
    	//for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
    	//for (i = n; i >= 1; --i) sa[cnt[rk[id[i] + w]]--] = id[i];
        
        memset(cnt,0,sizeof(int)*(m+5));
        //ins替换了id 避免不必要的误解，作用是暂存第二关键字排序结果
        for(int i=1;i<=n;i++) ins[i] = sa[i];
        for(int i=1;i<=n;i++) cnt[rk[i]]++;
        for(int i=1;i<=m;i++) cnt[i] += cnt[i-1];
        //这里必须从n到1，因为目前序列中第二关键字是有序的，仅根据第一关键字排序必须稳定。
        for(int i=n;i>=1;i--) sa[cnt[rk[ins[i]]]--] = ins[i];

        tail = 0;
        for(int i=1;i<=n;i++) ins[i] = rk[i];
        for(int i=1;i<=n;i++){
            if(ins[sa[i]] != ins[sa[i-1]] || ins[sa[i]+w] != ins[sa[i-1]+w])
                tail++;
            rk[sa[i]] = tail;
        }
        m = tail;
        if(m == n) break;
    }
    for(int i=1;i<n;i++) printf("%d ",sa[i]);
    printf("%d\n",sa[n]);
}

int main() {
#ifdef ACM_LOCAL
    freopen("x.txt","r",stdin);
#endif
    int T=1;
//    scanf("%d",&T);
    while(T--){
        solve();
    }
    return 0;
}
```

```c++
//第二关键字排序部分：常数优化版
//第二关键字排序的结果暂存在ins数组
tail = 0;
for(int i=n-w+1;i<=n;i++) ins[++tail] = i;
for(int i=1;i<=n;i++){
    if(sa[i] > w) ins[++tail] = sa[i] - w;
}
```

