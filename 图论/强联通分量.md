## Tarjan SCC缩点

Tarjian缩点写起来不难，但理解起来有一定难度，不搞明白的话，求割点和桥部分容易写假

 从dfs生成树的角度去考虑会比较清晰

https://www.luogu.com.cn/problem/P7251

```c++
int bel[maxn];
int dfn[maxn], low[maxn], dfcnt = 0;
stack<int> stk;
vector<int> vp[maxn];

void dfs(int p){
    dfn[p] = low[p] = ++dfcnt;
    stk.push(p);
    for(int v: vp[p]){
        if(!dfn[v]) dfs(v);
        if(!bel[v]) low[p] = min(low[p], low[v]);//这个必须是low[v]
    }
    if(low[p] == dfn[p]){
        while(stk.top() != p){
            bel[stk.top()] = p;
            stk.pop();
        }
        bel[p] = p;
        stk.pop();
        //dfn[p] == p的节点作为缩点后的节点，其他点bel这个点，siz也存储在这个点上
    }
}

void solve(){
    int n, m;
    cin >> n >> m;
    for(int i=1;i<=m;i++){
        int x, y; cin >> x >> y;
        vp[x].push_back(y);
    }
    for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i);
    
    //下面是回答这道题的部分
    vector<int> siz(n+1, 0);
    vector<bool> ru(n+1, false), cu(n+1, false);
    for(int i=1;i<=n;i++){
        siz[bel[i]]++;
        for(int v: vp[i]){
            cu[bel[i]] = true;
            ru[bel[v]] = true;
        }
    }
    int ans1 = 0, sumr = 0, sumc = 0;
    for(int i=1;i<=n;i++){
        if(bel[i] == i){
            ans1 = max(ans1, siz[i]);
            sumr += !ru[i];
            sumc += !cu[i];
        }
    }
    cout << ans1 << '\n' << max(sumr, sumc) << '\n';
}
```

求割点：

首先，割点是无向图中的概念，删去一个点后若极大联通分量数增加，则这个点为割点

用Tarjian方法求出每个点的 $dfn$ 和 $low$，如果某节点**存在一个子节点**满足 $low_v\ge dfn_p$，则它是割点

**重点**：注意这里的 $low$ 更新方式和Tarjian略有区别，首先搜索时要忽略掉父亲

在搜到未经过的点时，同样 $dfs$ 然后更新 $low_p = min(low_p, low_v)$

但当发现已经过的节点时，需要 $low_p = min(low_p, dfn_v)$，而在缩点时，更新必须是 $low_p=min(low_p, low_v)$。

我理解这里的本质区别在于，求缩点时我们关注当前节点 $p$ 能走到的最小dfn，只要能走的都要考虑，故更新时计算 $low_v$

而求割点/桥时，图是无向图，我们需要关注的是子节点 $v$ **不往回走**所能走到的最小dfn（当然了，无向图要是能随便乱走既不是哪都能去），和忽略fa同理。故对于一条往回走到 $x$ 的边，我们只需要知道它能走回到 $x$ 就行了，当然不能顺着再走一遍 $low_x$。

```c++
int ict[maxn];
int dfn[maxn], low[maxn], dfcnt = 0;
vector<int> vp[maxn];

void dfs(int p, int fa){
    dfn[p] = low[p] = ++dfcnt;
    int subt = 0;
    for(int v: vp[p]){
        if(v == fa) continue;
        if(!dfn[v]){
            dfs(v, p);
            subt++;
            low[p] = min(low[p], low[v]);
            if(low[v] >= dfn[p]) ict[p] = 1;
        }else{
            low[p] = min(low[p], dfn[v]);//这个必须是dfn[v]
        }
    }
    if(!fa) ict[p] = subt > 1;//对根节点特判：产生两个子树则为割点
}

void solve(){
    int n, m;
    cin >> n >> m;
    for(int i=1;i<=m;i++){
        int x, y; cin >> x >> y;
        vp[x].push_back(y);
        vp[y].push_back(x);
    }
    for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i, 0);
    int cnt = 0;
    for(int i=1;i<=n;i++) cnt += ict[i];
    cout << cnt << '\n';
    for(int i=1;i<=n;i++) if(ict[i]) cout << i << '\n';
}
```

求桥和求割点差不多，就只需要在枚举一个子节点时，如果 $low_v\gt dfn_p$，这条连边就是桥



#### 为什么要缩点

一般的有向图比无向图要复杂的多，很多时候单纯去dfs的话，会有很多情况需要注意。但缩点之后的图一定是一个**有向无环图**，性质就好多了。

注意不能想当然地认为简单的拓扑排序就能完成缩点，下面是个最简单反例：

```
1 2
2 1
2 3
```

