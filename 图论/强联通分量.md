## Tarjan SCC缩点

Tarjian缩点写起来不难，但理解起来有一定难度，不搞明白的话，求割点和桥部分容易写假

https://www.luogu.com.cn/problem/P7251

```c++
int bel[maxn];
int dfn[maxn], low[maxn], dfcnt = 0;
stack<int> stk;
vector<int> vp[maxn];

void dfs(int p){
    dfn[p] = low[p] = ++dfcnt;
    stk.push(p);
    for(int v: vp[p]){
        if(!dfn[v]) dfs(v);
        if(!bel[v]) low[p] = min(low[p], low[v]);
    }
    if(low[p] == dfn[p]){
        while(stk.top() != p){
            bel[stk.top()] = p;
            stk.pop();
        }
        bel[p] = p;
        stk.pop();
        //dfn[p] == p的节点作为缩点后的节点，其他点bel这个点，siz也存储在这个点上
    }
}

void solve(){
    int n, m;
    cin >> n >> m;
    for(int i=1;i<=m;i++){
        int x, y; cin >> x >> y;
        vp[x].push_back(y);
    }
    for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i);
    
    //下面是回答这道题的部分
    vector<int> siz(n+1, 0);
    vector<bool> ru(n+1, false), cu(n+1, false);
    for(int i=1;i<=n;i++){
        siz[bel[i]]++;
        for(int v: vp[i]){
            cu[bel[i]] = true;
            ru[bel[v]] = true;
        }
    }
    int ans1 = 0, sumr = 0, sumc = 0;
    for(int i=1;i<=n;i++){
        if(bel[i] == i){
            ans1 = max(ans1, siz[i]);
            sumr += !ru[i];
            sumc += !cu[i];
        }
    }
    cout << ans1 << '\n' << max(sumr, sumc) << '\n';
}
```

求割点：

首先，割点是无向图中的概念，删去一个点后若极大联通分量数增加，则这个点为割点

用Tarjian方法求出每个点的 $dfn$ 和 $low$，如果某节点存在一个子节点满足 $low_v\ge dfn_p$，则它是割点

这里的 $low$ 更新方式和Tarjian略有区别，首先搜索时要忽略掉父亲

在搜到未经过的点时，同样 $dfs$ 然后更新 $low_p = min(low_p, low_v)$

但当发现已经过的节点时，需要 $low_p = min(low_p, dfn_v)$

为什么不能拿 $low_v$ 更新？暂时我理解

```c++
int ict[maxn];
int dfn[maxn], low[maxn], dfcnt = 0;
vector<int> vp[maxn];

void dfs(int p, int fa){
    dfn[p] = low[p] = ++dfcnt;
    int subt = 0;
    for(int v: vp[p]){
        if(v == fa) continue;
        if(!dfn[v]){
            dfs(v, p);
            subt++;
            low[p] = min(low[p], low[v]);
            if(low[v] >= dfn[p]) ict[p] = 1;
        }else{
            low[p] = min(low[p], dfn[v]);
        }
    }
    if(!fa) ict[p] = subt > 1;//对根节点特判：产生两个子树则为割点
}

void solve(){
    int n, m;
    cin >> n >> m;
    for(int i=1;i<=m;i++){
        int x, y; cin >> x >> y;
        vp[x].push_back(y);
        vp[y].push_back(x);
    }
    for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i, 0);
    int cnt = 0;
    for(int i=1;i<=n;i++) cnt += ict[i];
    cout << cnt << '\n';
    for(int i=1;i<=n;i++) if(ict[i]) cout << i << '\n';
}
```

求桥和求割点差不多，就只需要在枚举一个子节点时，如果 $low_v\gt dfn_p$，这条连边就是桥

